1. Понятия требований к разработке ПО, классификация, уровни требований
Определение:
Требования к разработке ПО — это описания функциональных и нефункциональных характеристик системы, определяющие её поведение, ограничения и цели.

Классификация:

    Функциональные: описывают, что система должна делать (например, обработка данных, логика работы).
    Нефункциональные: описывают, как система должна работать (производительность, безопасность, масштабируемость).
    Бизнес-требования: стратегические цели системы.
    Пользовательские требования: потребности конечных пользователей.
    Системные требования: подробное описание реализации функций.

Уровни:

    Бизнес-уровень: общие цели и задачи.
    Пользовательский уровень: функции с точки зрения пользователей.
    Технический уровень: детали реализации и спецификации.



2. Методологии и стандарты, регламентирующие работу с требованиями
Методологии:
    Waterfall: линейный процесс, сбор требований на начальном этапе.
    Agile: итеративный подход, требования уточняются по мере работы.
    Scrum: методология Agile с акцентом на спринты.

Стандарты:

    ISO/IEC/IEEE 29148:2011 — управление требованиями, их спецификация.
    BABOK (Business Analysis Body of Knowledge) — практическое руководство для бизнес-анализа.
    IEEE 830 — стандарт описания требований к ПО.
    ISO 25010 — описание качественных характеристик ПО.




3. Методы организации работы в команде разработчиков
    Scrum: роли (Scrum Master, Product Owner, команда), встречи (спринты, ежедневные стендапы).
    Kanban: визуализация задач с помощью досок, работа над текущими задачами.
    Extreme Programming (XP): акцент на тестировании, кодировании парами.
    Lean: устранение потерь, минимизация незавершённой работы.
    DevOps: интеграция разработки и эксплуатации.

Инструменты: Jira, Trello, Confluence, Git, Slack.




4. Тестовое покрытие. Тестовый сценарий, тестовый пакет
Тестовое покрытие:
Метрика, отражающая процент проверенных тестами частей кода (функциональностей, путей выполнения).

Виды тестового покрытия:

    Покрытие функций.
    Покрытие кода (строк, ветвей).
    Покрытие требований.

Тестовый сценарий (Test Case):
Документ, описывающий последовательность шагов и ожидаемый результат для проверки функциональности.

Тестовый пакет (Test Suite):
Набор связанных тестовых сценариев, объединённых общей целью.




5. Унифицированный язык моделирования UML. Нотации
Определение UML:
Унифицированный язык моделирования (Unified Modeling Language) — стандарт для визуализации, описания и документирования систем.

Основные диаграммы:

    Диаграмма классов: описывает структуры данных и их связи.
    Диаграмма случаев использования (Use Case): показывает взаимодействие пользователя с системой.
    Диаграмма последовательностей: отражает взаимодействие объектов во времени.
    Диаграмма активности: описывает бизнес-процессы и потоки управления.
    Диаграмма состояний: отображает изменения состояний объекта.

Нотации UML:

    Прямоугольники: классы, объекты.
    Овалы: случаи использования.
    Стрелки: зависимости, ассоциации, потоки.
    Ромбики: агрегирование или композиция.


6. Диаграммы UML – общая характеристика
Определение:
UML (Unified Modeling Language) — стандарт визуального моделирования систем. Диаграммы UML помогают описывать структуру, поведение и взаимодействие системы.

Типы диаграмм:

    Структурные: описывают статические аспекты системы.
        Диаграмма классов.
        Диаграмма компонентов.
        Диаграмма объектов.
        Диаграмма развёртывания.
    Поведенческие: описывают динамику и взаимодействия.
        Диаграмма активности.
        Диаграмма последовательностей.
        Диаграмма состояний.
        Диаграмма случаев использования.

Ценность UML:

    Упрощает разработку сложных систем.
    Позволяет всем участникам понимать проект.
    Универсальный язык для анализа, проектирования и документирования.




7. Предметы UML. Отношения UML
Предметы UML:

    Структурные элементы:
        Классы: основные строительные блоки, представляют сущности.
        Актеры: внешние пользователи системы.
        Компоненты: части системы, обеспечивающие определённую функциональность.
        Объекты: экземпляры классов.

    Поведенческие элементы:
        Действия (activities): показывают операции.
        События: изменения состояний.

    Группирующие элементы:
        Пакеты: объединяют элементы в группы.

    Аннотирующие элементы:
        Примечания для дополнительной информации.

Отношения UML:

    Ассоциация: связь между классами.
    Агрегация: «часть-целое», связь слабая.
    Композиция: более жёсткая форма агрегации, «часть не существует без целого».
    Обобщение (наследование): отношение «is-a».
    Зависимость: слабая связь, когда один элемент использует другой.




8. Создание в UML моделей анализа требований
Цель:
Создание моделей, которые помогают понять и уточнить требования к системе.

Основные диаграммы для анализа:

    Диаграмма случаев использования (Use Case):
        Показывает основные функции системы и их взаимодействие с пользователями.
        Упрощает сбор и обсуждение требований.

    Диаграмма активности:
        Показывает последовательность действий, процессов.
        Полезна для описания бизнес-логики.

    Диаграмма состояний:
        Демонстрирует, как объект переходит из одного состояния в другое в ответ на события.

    Диаграмма классов:
        Анализ сущностей, их свойств и связей на этапе проектирования.

Пример работы:

    Сначала создаются случаи использования для понимания функционала.
    Затем дополняются модели поведения (активности, состояния).




9. Компонентные диаграммы UML
Определение:
Компонентная диаграмма UML отображает структуру и взаимосвязи между компонентами системы (модулями или библиотеками).

Цель:
Показать, как реализованы функциональные части системы.

Основные элементы:

    Компоненты:
        Модуль или часть системы, выполняющая определённую функцию.
    Интерфейсы:
        Точки взаимодействия между компонентами.
    Зависимости:
        Указывают, как компоненты зависят друг от друга.

Пример:

    В системе e-commerce компонент «Каталог товаров» зависит от компонента «База данных».




10. Описание и оформление требований (спецификация)
Описание требований:

    Требования фиксируют, что должна делать система (функционал) и как она должна работать (ограничения).
    Включает:
        Бизнес-требования: общие цели.
        Пользовательские требования: функционал, ожидаемый пользователями.
        Системные требования: технические детали.

Оформление:

    Шаблон спецификации:
        Введение: цели проекта, заинтересованные стороны.
        Описание системы: основные функции и ограничения.
        Функциональные требования: подробности функций.
        Нефункциональные требования: производительность, безопасность.

    Язык:
        Используйте чёткие и однозначные формулировки.
        Пример: «Система должна обрабатывать 100 запросов в секунду».

    Методы:
        Использование таблиц, диаграмм UML для визуализации.
        Приоритетизация требований (например, Must-Have, Should-Have).

    Спецификация требований — это документ, который чётко описывает функциональные и нефункциональные требования к системе. Он служит основой для разработки, тестирования и валидации ПО.
    Структура спецификации:
        Введение: описание проекта, цели и заинтересованные стороны.
        Общее описание: обзор системы, её компоненты.
        Функциональные требования: детализированные функции системы.
        Нефункциональные требования: требования к производительности, безопасности, надёжности.
        Ограничения и допущения: технологические, аппаратные ограничения.

Анализ требований:
Анализ включает в себя:

    Идентификацию заинтересованных сторон.
    Выявление и уточнение требований (с использованием интервью, опросов, прототипов).
    Проверку полноты и консистентности требований.
    Управление изменениями требований на протяжении проекта.

Стратегии выбора решения:

    Быстрое прототипирование: создание рабочего прототипа для получения обратной связи.
    Моделирование: использование диаграмм UML для визуализации требований.
    Использование стандартных решений: для частых проблем выбираются проверенные решения.
    Анализ рисков: оценка рисков для выбора наилучшего подхода.





11. Оценки программного проекта. Определение метрики.
Оценка программного проекта:
Оценка программы — это процесс определения стоимости, сроков и качества проекта. Она позволяет планировать ресурсы, риски и управлять проектом.

Метрики — это количественные показатели, которые помогают измерять различные аспекты разработки ПО.

Типы метрик:

    Метрики размера: количество строк кода, количество классов.
    Метрики производительности: скорость выполнения, время отклика системы.
    Метрики качества: количество дефектов, время исправления ошибок.

Применение метрик:

    Оценка трудозатрат и сроков.
    Анализ производительности.
    Оценка качества кода и архитектуры.




12. Размерно-ориентированные метрики ПС
Определение:
Размерно-ориентированные метрики измеряют размеры различных аспектов программного обеспечения, что может быть использовано для оценки трудозатрат, сроков разработки и сложности проекта.

Примеры метрик:

    Количество строк кода (SLOC): часто используется для оценки размера программного продукта.
    Количество функций (Function Points): измеряет количество функций, выполняемых системой, в зависимости от типа данных, операций и пользовательских интерфейсов.
    Число классов или методов: для объектно-ориентированных систем.

Недостатки:

    Не всегда отражает реальную сложность системы.
    Может не учитывать качество кода или архитектуры.




13. Функционально-ориентированные метрики ПС
Определение:
Функционально-ориентированные метрики измеряют функциональные аспекты системы и её способность выполнять заданные задачи.

Примеры метрик:

    Function Points (FP): оценивает функциональность системы на основе количества входных/выходных данных, запросов, отчетов и т.д.
    Метрики сложности алгоритмов: например, количество циклов в алгоритме, вычислительная сложность.

Преимущества:

    Больше ориентированы на реальные возможности системы, чем на её размер.
    Лучше оценивают функциональность и сложность, чем просто количество строк кода.




14. Объектно-ориентированные метрики ПС
Определение:
Объектно-ориентированные метрики оценивают качество, структуру и сложность объектно-ориентированных систем.

Примеры метрик:

    Число классов (Number of Classes): количество классов в проекте.
    Число методов на класс (Number of Methods per Class): количество методов в классе.
    Глубина наследования (Inheritance Depth): глубина иерархии наследования.
    Цикломатическая сложность (Cyclomatic Complexity): сложность системы на основе числа независимых путей в коде.
    Коэффициент связности (Cohesion): степень внутренней связи элементов класса.

Преимущества:

    Оценка степени модульности и переиспользуемости кода.
    Помогают улучшить дизайн системы и её расширяемость.




15. Понятие репозитория проекта, структура проекта
Репозиторий проекта:
Репозиторий проекта — это централизованное хранилище для всех файлов и артефактов проекта, включая исходный код, документацию, требования, тесты и т.д. Репозитории управляют версиями и позволяют команде работать с проектом совместно.

Типы репозиториев:

    Системы контроля версий (VCS): Git, SVN.
    Репозитории для совместной работы: GitHub, GitLab, Bitbucket.
    Артефактные репозитории: Maven, Nexus, Artifactory — хранят бинарные файлы и зависимости.

Структура проекта:

    src: исходный код.
    bin: скомпилированные файлы.
    docs: документация.
    tests: тесты.
    lib: сторонние библиотеки.
    build: скрипты для сборки проекта.

Репозиторий и структура проекта помогают организовать эффективную работу команды, минимизируя конфликты и повышая производительность.




16. Виды, цели и уровни интеграции программных модулей
Виды интеграции:

    Интеграция по методу "большого взрыва" (Big Bang): все модули собираются и тестируются одновременно.
    Поэтапная интеграция: модули интегрируются поочередно, один за другим.
    Инкрементальная интеграция: модули интегрируются небольшими частями или этапами, постепенно.
    Интеграция через интерфейсы (API): модули интегрируются с использованием заранее определённых интерфейсов.

Цели интеграции:

    Проверка взаимодействия компонентов: убедиться, что модули работают корректно вместе.
    Выявление ошибок в интерфейсах: нахождение дефектов взаимодействия между модулями.
    Обеспечение стабильности системы: интеграция должна обеспечивать функциональность и надёжность.

Уровни интеграции:

    Интеграция на уровне модулей: интеграция отдельных программных компонентов.
    Интеграция на уровне системы: объединение всех компонентов в единую работающую систему.
    Интеграция на уровне подсистем: интеграция логически связанных наборов модулей или сервисов.




17. Организация работы команды в системе контроля версий
Основные принципы работы в системе контроля версий (VCS):

    Централизованный контроль версий (например, SVN) или распределённый (например, Git).
    Каждый разработчик работает в своей локальной копии репозитория и периодически синхронизирует её с центральным.

Процесс работы с VCS:

    Клонирование репозитория: каждый разработчик создает локальную копию проекта.
    Создание веток: для работы над новой функцией или задачей создаются отдельные ветки.
    Коммиты: регулярные сохранения изменений в репозитории с описанием сделанных изменений.
    Слияние веток: после завершения работы над задачей ветка сливается с основной (например, master или main).
    Решение конфликтов: при слиянии может возникнуть конфликт, который нужно вручную разрешить.
    Использование pull request (PR): для обсуждения изменений и их интеграции в основную ветку.




18. Отладка программных продуктов
Отладка — это процесс поиска и устранения ошибок в программе. Она включает в себя:

    Выявление ошибок: с помощью отладчиков, логов, тестов.
    Анализ состояния программы: проверка значений переменных, состояний объектов.
    Исправление ошибок: внесение изменений в код для исправления дефектов.
    Повторное тестирование: проверка, что исправления не привели к новым ошибкам.

Типы отладки:

    Статическая отладка: анализ кода без его выполнения (например, с помощью линтеров).
    Динамическая отладка: проверка программы в процессе её выполнения (например, с использованием отладчиков).

Цели отладки:

    Обнаружение логических и синтаксических ошибок.
    Улучшение производительности и стабильности.




19. Инструменты отладки. Отладочные классы
Инструменты отладки:

    Отладчики: программы для пошагового выполнения кода, просмотра значений переменных и анализа стека вызовов.
        Примеры: GDB, Visual Studio Debugger, Xcode Debugger.
    Логгеры: инструменты для записи сообщений об ошибках, предупреждениях и важной информации в ходе выполнения программы.
        Примеры: Log4j, SLF4J, Python logging.
    Профилировщики: инструменты для анализа производительности программы, выявления узких мест.
        Примеры: JProfiler, VisualVM, Valgrind.

Отладочные классы:

    Тестовые классы: специальные классы для тестирования модулей и компонентов системы (например, JUnit для Java).
    Логирующие классы: классы, специально предназначенные для ведения логов работы программы.
    Псевдоклассы: временные или вспомогательные классы, создаваемые для отладки, например, для отслеживания состояния системы или имитации отсутствующих компонентов.




20. Инструментарии анализа качества программных продуктов в среде разработки
Инструменты анализа качества ПО:

    Линтеры (статический анализ кода):
        Примеры: ESLint, Checkstyle, Pylint.
        Линтеры проверяют стиль и качество кода, ищут ошибки, предупреждают о потенциальных проблемах.

    Инструменты для анализа покрытия кода:
        Примеры: JaCoCo, Cobertura, pytest-cov.
        Эти инструменты помогают измерить процент кода, покрытого тестами, и выявить его неохваченные части.

    Профилировщики:
        Примеры: JProfiler, VisualVM, YourKit.
        Используются для анализа производительности, памяти и ресурсов, а также для выявления утечек памяти.

    Инструменты для анализа зависимостей:
        Примеры: SonarQube, DepCheck.
        Оценка зависимости, конфликты версий и устаревшие библиотеки.

    Тестирование на безопасность:
        Примеры: OWASP ZAP, Burp Suite.
        Эти инструменты позволяют проводить тесты на уязвимости безопасности.

Задачи инструментариев:

    Обеспечение соблюдения стандартов кода.
    Повышение производительности кода.
    Повышение безопасности приложения.
    Улучшение покрытия кода тестами.




21. Обработка исключительных ситуаций
Обработка исключений — это процесс обработки ошибок, возникающих во время выполнения программы. Цель — предотвратить аварийное завершение программы и корректно обработать ошибки.

Основные элементы обработки исключений:

    Блоки try-catch (или эквиваленты в других языках) — позволяют перехватывать и обрабатывать исключения.
        try — код, в котором может возникнуть ошибка.
        catch — блок, в котором осуществляется обработка исключений.
    Иерархия исключений: исключения могут быть стандартными (например, IOException) или пользовательскими.
    Переподнятие исключений: когда ошибка не может быть обработана в текущем контексте, исключение может быть передано выше по стеку вызовов.
    Логирование: для диагностики ошибок часто используется логирование исключений с сохранением их в файл.




22. Методы и способы идентификации сбоев и ошибок
Методы идентификации ошибок и сбоев:

    Тестирование: использование юнит-тестов, функциональных тестов, тестов производительности для выявления дефектов.
    Логирование: автоматическое логирование событий для последующего анализа и поиска сбоев.
    Отладка: с помощью отладчиков можно пошагово анализировать выполнение программы и выявлять проблемы.
    Анализ стека вызовов: позволяет понять, в каком месте произошёл сбой.
    Мониторинг производительности: отслеживание системных метрик, таких как использование памяти, CPU, для обнаружения проблем в реальном времени.
    Анализ кодов ошибок: при возникновении ошибки система может возвращать коды, которые затем анализируются для диагностики проблемы.





23. Инструментально-объектный подход к разработке программного средства
Инструментально-объектный подход — это метод разработки ПО, который включает использование инструментов для автоматизации процессов разработки (например, IDE, системы контроля версий) и ориентацию на объектно-ориентированное программирование (ООП).

Основные характеристики:

    Модульность и повторное использование: использование объектов и классов для создания легко изменяемых и расширяемых компонентов.
    Использование инструментов разработки: интегрированные среды разработки (IDE), которые помогают автоматизировать сборку, тестирование, отладку.
    Снижение зависимости от конкретных технологий: проектирование и разработка модулей с минимальной зависимостью от технологий и платформ.





24. Основные классы инструментальных сред разработки и сопровождения программных средств. Инструментальные среды программирования
Основные классы инструментальных сред разработки:

    Среды разработки (IDE): инструменты для написания, отладки и компиляции кода (например, Visual Studio, Eclipse, IntelliJ IDEA).
    Системы контроля версий: позволяют отслеживать изменения в коде и обеспечивают совместную работу над проектом (например, Git, Subversion).
    Средства тестирования: инструменты для автоматического тестирования ПО (например, JUnit, TestNG).
    Системы управления проектами: помогают планировать, контролировать и управлять задачами и ресурсами проекта (например, JIRA, Trello).
    Средства анализа и профилирования кода: позволяют анализировать производительность и качество кода (например, SonarQube, JProfiler).

Инструментальные среды программирования включают все вышеперечисленные инструменты для создания, тестирования и сопровождения программных продуктов.




25. Базовые стратегии разработки ПС, достоинства и недостатки
Основные стратегии разработки:

    Водопадная модель (Waterfall):
        Достоинства: чёткая структура, легко управлять, на каждом этапе есть конкретные цели.
        Недостатки: сложность в изменении требований, невозможность возвращаться к предыдущим этапам.

    Итеративная и инкрементальная модели:
        Достоинства: позволяет вносить изменения на каждом этапе, быстрее выявляются проблемы.
        Недостатки: может быть сложным контролировать сроки и ресурсы, если изменения значительные.

    Гибкая методология (Agile):
        Достоинства: гибкость в ответ на изменения требований, быстрое тестирование и выпуск продуктов.
        Недостатки: сложность в долгосрочном планировании, высокая нагрузка на команду.

    Радикальные и экстремальные методологии (Extreme Programming):
        Достоинства: высокая степень вовлеченности заказчика, постоянная обратная связь.
        Недостатки: высокие требования к подготовке команды, трудности с масштабированием.





26. Основной компонент инструментальных систем технологии программирования репозитория
Репозиторий — это централизованное хранилище для всех компонентов программного проекта, таких как исходный код, тесты, документация, библиотеки и другие артефакты.

Основные компоненты репозитория:

    Хранилище версий: база данных, которая хранит все изменения в исходном коде и других файлах проекта.
    Система управления версиями (VCS): инструменты для отслеживания изменений и контроля версий, такие как Git, SVN, Mercurial.
    Метаданные: информация о файлах и их версии, статусах, участниках проекта и т. д.

Репозиторий помогает централизованно управлять исходным кодом, улучшая взаимодействие между членами команды и предотвращая потерю данных.




27. Понятие CASE – средства, их назначение и применение. Свойства современных CASE-средств, обеспечивающие поддержку процесса разработки программных продуктов
CASE (Computer-Aided Software Engineering) — это средства, которые помогают автоматизировать и поддерживать различные этапы разработки ПО.

Назначение CASE-средств:

    Моделирование: средства для создания диаграмм (например, UML).
    Генерация кода: автоматическое создание исходного кода из моделей.
    Управление требованиями: инструменты для управления требованиями и их отслеживания.
    Тестирование и валидация: средства для автоматического тестирования и обеспечения качества.

Свойства современных CASE-средств:

    Интеграция с другими инструментами: поддержка интеграции с системами контроля версий, тестирования, сборки.
    Поддержка различных методологий разработки: например, поддержка Agile, Waterfall.
    Поддержка стандартов: возможность работы с международными стандартами моделирования (UML, BPMN).
    Автоматизация задач: снижение рутинных задач, таких как генерация документации и кода.





28. Математические модели, принципы их построения, виды моделей
Математические модели — это абстракции реальных объектов или процессов, выраженные с помощью математических формул, уравнений и алгоритмов.

Принципы построения математических моделей:

    Определение объекта моделирования: чёткое понимание, что моделируется.
    Сбор данных и параметров: определение необходимых входных данных для модели.
    Построение модели: использование математических методов (алгебра, дифференциальные уравнения и т.д.).
    Верификация и валидация: проверка модели на реальных данных.

Виды моделей:

    Статистические модели: используются для описания случайных процессов.
    Динамические модели: для описания процессов во времени (например, модели роста населения).
    Алгоритмические модели: для решения задач оптимизации или вычислений.





29. Понятие решения. Множество решений, оптимальное решение. Показатель эффективности решения
Решение — это результат, полученный в процессе принятия выбора из множества возможных вариантов.

Множество решений — это все возможные альтернативы, которые можно рассматривать как решения задачи.

Оптимальное решение — решение, которое минимизирует или максимизирует целевую функцию задачи, при этом удовлетворяя всем ограничениям.

Показатель эффективности решения:

    Качество решения: насколько оно соответствует цели.
    Ресурсы, затраченные на решение: время, деньги, материалы и другие ресурсы.





30. Общий вид и основная задача линейного программирования. Симплекс – метод
Линейное программирование — это метод оптимизации, использующий линейные функции для определения наилучшего решения задачи с учётом ограничений.

Общий вид задачи линейного программирования:
Максимизация или минимизация линейной функции:
Maximize c1x1+c2x2+⋯+cnxn
Maximize c1​x1​+c2​x2​+⋯+cn​xn​

при ограничениях вида:
a1x1+a2x2+⋯+anxn≤b
a1​x1​+a2​x2​+⋯+an​xn​≤b

Симплекс-метод — это алгоритм для решения задач линейного программирования, который перебирает вершины допустимой области (множества решений) и находит оптимальное решение за конечное количество шагов.




31. Транспортная задача. Методы нахождения начального решения транспортной задачи. Метод потенциалов
Транспортная задача — задача оптимизации, где нужно определить, как перевозить товары от нескольких поставщиков к нескольким потребителям с минимальными затратами, при этом учитываются ограничения по количеству товаров у поставщиков и потребителей.

Методы нахождения начального решения:

    Метод северо-западного угла: начинается с верхнего левого угла таблицы и заполняет решения, двигаясь по диагонали, пока не будут учтены все ограничения.
    Метод минимальной стоимости: выбирается маршрут с минимальной стоимостью, и решается для него задача, пока не будут удовлетворены все ограничения.
    Метод ближайшего угла: на каждом шаге выбирается минимальная стоимость из оставшихся, начиная с углов, и продолжается по всей таблице.

Метод потенциалов — это метод нахождения оптимального решения транспортной задачи, который используется после нахождения начального решения с помощью одного из методов. Он включает определение потенциалов для строк и столбцов, затем проверку, что все перемещения являются оптимальными.





32. Общий вид задач нелинейного программирования. Графический метод решения задач нелинейного программирования.
Задачи нелинейного программирования — задачи оптимизации, в которых хотя бы одна из функций (целевая или ограничивающая) является нелинейной.

Общий вид задачи нелинейного программирования:
Maximize/Minimize f(x1,x2,...,xn)
Maximize/Minimize f(x1​,x2​,...,xn​)

при ограничениях:
gi(x1,x2,...,xn)≤0,i=1,2,...,m
gi​(x1​,x2​,...,xn​)≤0,i=1,2,...,m

где ff и gigi​ — нелинейные функции.

Графический метод решения: используется только для задач с двумя переменными. Решение состоит в том, чтобы:

    Нарисовать графики функции f(x1,x2)f(x1​,x2​) и ограничений gi(x1,x2)gi​(x1​,x2​).
    Найти область допустимых решений (пересечение ограничений).
    На этой области максимизировать или минимизировать целевую функцию.





33. Основные понятия динамического программирования
Динамическое программирование (ДП) — метод решения сложных задач путём их разбиения на более простые подзадачи. Для каждой подзадачи сохраняются результаты, что позволяет избегать повторного вычисления.

Основные понятия:

    Принцип оптимальности: решение задачи можно построить, если оптимальны её подзадачи.
    Разбиение на подзадачи: задача делится на несколько меньших, и решения этих подзадач комбинируются для получения решения исходной задачи.
    Мемоизация: хранение уже решённых подзадач для предотвращения избыточных вычислений.





34. Задача о нахождении кратчайших путей в графе и методы её решения
Задача о кратчайших путях: нахождение пути с минимальной длиной или стоимостью в графе от начальной вершины до целевой.

Методы решения:

    Алгоритм Дейкстры: находит кратчайшие пути от одной вершины до всех остальных в графе с неотрицательными весами рёбер.
    Алгоритм Беллмана-Форда: находит кратчайшие пути в графах с отрицательными весами рёбер, но без отрицательных циклов.
    Алгоритм Флойда: используется для нахождения кратчайших путей между всеми парами вершин в графе.





35. Задача о максимальном потоке и алгоритм Форда-Фалкерсона
Задача о максимальном потоке: задача нахождения максимального потока, который может быть перемещён через сеть от источника к стоку, с учётом ограничений на пропускную способность рёбер.

Алгоритм Форда-Фалкерсона:

    Поиск увеличивающего пути: находит путь в графе, по которому ещё можно увеличить поток.
    Увеличение потока: увеличивает поток вдоль найденного пути.
    Повторение: процесс повторяется, пока существует путь с положительным остаточным потоком.




36. Математические, имитационные и эвристические модели исследования операций. Понятие допустимого и оптимального решения задач линейного программирования
Математические модели: используют математические выражения для представления реальных систем и процессов. Примеры: линейное программирование, задачи оптимизации.

Имитационные модели: моделируют поведение системы с помощью имитации, обычно с использованием случайных процессов и статистических данных (например, методы Монте-Карло).

Эвристические модели: используют методы, которые дают приближённые решения для сложных задач, когда точное решение невозможно из-за сложности или времени (например, жадные алгоритмы).

Допустимое решение — решение, которое удовлетворяет всем ограничениям задачи.

Оптимальное решение — решение, которое даёт наилучший результат по целевой функции при соблюдении всех ограничений.





37. Системы массового обслуживания: понятия, примеры, модели 1
Системы массового обслуживания (СМО) — это системы, в которых объекты обслуживания (например, клиенты) поступают в систему и обслуживаются с помощью серверов (например, кассиров, машин). Задачи, решаемые СМО, связаны с анализом времени ожидания, длины очереди и мощности системы.

Примеры:

    Очереди в банках или магазинах.
    Обслуживание телефонных вызовов.
    Обслуживание клиентов в ресторанах или гостиницах.

Модели СМО:

    Модель M/M/1: одна очередь и один сервер, потоки поступлений и обслуживания — пуассоновские.
    Модель M/M/c: несколько серверов.
    Модель M/G/1: общее распределение времени обслуживания при одном сервере.




38. Схема гибели и размножения
Схема гибели и размножения описывает модели популяций, где особи могут погибать (с определенной вероятностью) и размножаться (с созданием новых особей). Эта схема используется в экологии, биологии и некоторых моделях популяционной динамики.

Основные элементы:

    Гибель: процесс уменьшения численности популяции из-за различных факторов.
    Размножение: процесс увеличения популяции за счет появления новых особей.





39. Понятие прогноза. Количественные методы прогнозирования. Качественные методы прогноза.
Прогноз — это предсказание будущих событий на основе анализа текущей ситуации и прошлых данных.

Количественные методы прогнозирования:

    Метод экстраполяции: прогнозирование на основе трендов, выявленных в исторических данных.
    Регрессионный анализ: использование статистических методов для предсказания зависимостей между переменными.
    Метод времени рядов: анализ исторических данных по времени с целью прогнозирования будущих значений.

Качественные методы прогнозирования:

    Метод экспертов: прогнозирование на основе знаний и опыта экспертов в данной области.
    Метод делфи: метод прогнозирования, основанный на анонимных опросах группы экспертов.





40. Основные понятия теории игр. Антагонистические матричные игры: чистые и смешанные стратегии.
Теория игр — это раздел математики, изучающий стратегическое поведение в ситуациях, когда результат зависит не только от действий одного участника, но и от действий других участников.

Основные понятия:

    Игроки: участники игры.
    Стратегии: возможные действия игроков.
    Результаты: исход игры, определяемый стратегиями игроков.

Антагонистические матричные игры — это игры, где интересы игроков противоположны (например, два игрока соревнуются за выигрыш).

    Чистая стратегия: игрок всегда выбирает одно и то же действие.
    Смешанная стратегия: игрок выбирает действия случайным образом с заданными вероятностями.